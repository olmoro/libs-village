# MQTT клиент для ESP32 / ESP-IDF

> If you do not understand this text, please use the English version: <br/>https://github.com/kotyara12/reMqtt/blob/master/README_EN.md <br/>Sorry for the machine translation into English.


MQTT клиент ESP32 и ESP-IDF (_не будет работать в Arduino_) с возможностью настройки до двух MQTT брокеров с автоматическими переключением между ними. Брокер может быть "_локальным_" (то есть доступным только в пределах локальной сети, к которой подключено ESP), либо "_публичным_" (то есть доступным из сети интернет). Это позволяет реализовать схему работы, когда в качестве основого MQTT брокера используется [локальный сервер на роутере с мостом на внешний](https://kotyara12.ru/pubs/iot/keenetic-mqtt/) (либo брокер Home Assistant, например), а в качестве резервного - любой публичный. В этом случае, при потере доступа из локальной сети к интернет устройство продолжает успешно функционировать на локальном брокере, но мы теряем возможность внешнего управления извне. И наоборот, если по какой-либо причине происходит потеря доступа к основному брокеру, то устройство автоматически переключится на резервный сервер. Можно также указать в качестве основного и резервного брокра публичные сервера, просто повысив надежность системы. Либо использовать только один сервер, как обычно.

Библиотека основана на ESP-IDF библиотеке "mqtt_client.h", поэтому вряд ли будет работать на Arduino фреймворке. По сути, это просто "обертка" вокруг "mqtt_client.h" для более удобного использования и автоматического выбора сервера. Вам следует учесть, что данная библиотека интегрирована в удобную событийную систему, релизованную с помощью других библиотек [reEvents](https://github.com/kotyara12/reEvents) и [reStates](https://github.com/kotyara12/reStates). _Полный список зависимостей от других библиотек смотрите ниже в разделе "Зависимости"_. Если вы не планируете использовать весь набор библиотек, представленных в моем профиле, вам стоит создать форк и изменить код по своему желанию.

## Использование:

### Создание и запуск задачи MQTT клиента
Функция ```mqttTaskStart``` создает и, возможно, запускает задачу MQTT-клиента. Параметр ```createSuspended``` позволяет _создать задачу в приостановленном виде_, чтобы _запустить её позже по событию подключения к WiFi сети_ и (или) получению доступа в интернет. В случае успеха функция вернет true.
```
bool mqttTaskStart(bool createSuspended);
```
### Остановка и удаление задачи MQTT клиента
Данная функция может быть вызвана перед перезагрузкой устройства. В случае успеха функция вернет true.
```
bool mqttTaskStop();
```

### Приостановка и восстановление задачи MQTT клиента
```
bool mqttTaskSuspend();
bool mqttTaskResume();
```
Данные функции могут быть использованы для приостановки задачи на время, когда устройство отключилось от WiFi сети или потерян доступ к серверу. В случае успеха функция вернет true.

### Регистрация обработчиков событий 
Функция ```mqttEventHandlerRegister``` выполняет регистрацию обработчиков событий модуля в основном цикле событий [reEvents](https://github.com/kotyara12/reEvents). 
```
bool mqttEventHandlerRegister();
```
С помощью этого клиент MQTT будет автоматически запущен или остановлен по событиям подключения к WiFi сети. Кроме того, задача MQTT клиента сама отправляет события подключения или отключения к MQTT брокеру для оповещения других подсистем прошивки. В случае успеха функция вернет true.

### Получение статуса подключения
С помощью функции ```mqttIsConnected``` можно узнать, подключен ли клиент к брокеру в данный момент или нет.
```
bool mqttIsConnected();
```

### Подписка на топики
**Подписка на топик** ```topic``` с заданным ```QoS```. В случае успеха функция вернет true.
```
bool mqttSubscribe(const char *topic, int qos);
```

**Отмена подписки на ранее подписанный топик** ```topic```. В случае успеха функция вернет true.
```
bool mqttUnsubscribe(const char *topic);
```

### Публикация сообщения в топик
Публикация сообщения ```payload``` в заданный топик ```topic``` с заданными параметрами ```QoS``` и ```retained```.<br/>
Если установлен бит ```forced```, то попытка отправки сообщения будет предпринята немедленно _в контексте вызывающей задачи_; иначе сообщение будет поставлено в очередь и отправлено позже _в контексте задачи MQTT клиента_.<br/>
При ```free_topic = true``` переданная строка ```char *topic``` будет удалена из кучи после отправки.<br/>
Аналогично, при ```free_payload = true``` переданная строка ```char *payload``` будет удалена из кучи после отправки.<br/>
```
bool mqttPublish(char *topic, char *payload, int qos, bool retained, bool forced, bool free_topic, bool free_payload);
```

## Зависмости:
  - esp_event_base.h (ESP-IDF)
  - mqtt_client.h (ESP-IDF)
  - project_config.h (настройки проекта)
  - https://github.com/kotyara12/rLog
  - https://github.com/kotyara12/rStrings
  - https://github.com/kotyara12/reEsp32
  - https://github.com/kotyara12/reEvents
  - https://github.com/kotyara12/reStates
  - https://github.com/kotyara12/reWifi
  - https://github.com/kotyara12/reNvs

## Примечания:
Данные замечания относятся к моим библиотекам, размещенным на ресурсе https://github.com/kotyara12?tab=repositories.

- библиотеки, название которых начинается с префикса **re**, предназначены только для ESP32 и ESP-IDF (FreeRTOS)
- библиотеки, название которых начинается с префикса **ra**, предназначены только для ARDUINO
- библиотеки, название которых начинается с префикса **r**, могут быть использованы и для ARDUINO, и для ESP-IDF

Так как я в настроящее время разрабатываю программы в основном для ESP-IDF, основная часть моих библиотек предназначена только для этого фреймворка. Но Вы можете портировать их для другой системы, взяв за основу.
